<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>pictr — delightful one-file photo editor</title>
<style>
  :root{
    --bg:#0a0f16; --bg2:#0d141d; --card:#0f1724; --card2:#101b2b;
    --text:#e8f0fb; --muted:#9fb0c9; --muted2:#7f93b3;
    --border:#172235; --border2:#20324a;
    --accent:#68e0ff; --accent2:#a58bff; --ok:#34d399; --warn:#f59e0b; --danger:#ef4444;
    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:
      radial-gradient(1000px 600px at 10% -20%, #0e1930 0%, transparent 60%),
      radial-gradient(900px 600px at 90% -20%, #102237 0%, transparent 60%),
      linear-gradient(180deg, #0a0f16 0%, #0a0f16 100%);
    color:var(--text);
    font:14px/1.35 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow:hidden;
  }

  .app{display:grid;grid-template-rows:72px 1fr 54px;height:100%}

  header{
    display:flex;align-items:center;gap:12px;padding:10px 14px;border-bottom:1px solid var(--border);
    background:linear-gradient(180deg,#0f1622,#0b121c); position:relative; z-index:3;
  }
  .brand{display:flex;align-items:center;gap:10px;font-weight:800;font-size:18px;letter-spacing:.2px;text-transform:lowercase}
  .brand .dot{width:12px;height:12px;border-radius:50%;
    background:conic-gradient(from 180deg,var(--accent),var(--accent2));box-shadow:0 0 18px var(--accent)}
  .spacer{flex:1}

  .btn{
    background:linear-gradient(180deg,#172233,#121a27);border:1px solid var(--border);
    color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;
    transition:transform .12s ease, background .12s ease, box-shadow .12s ease; user-select:none; white-space:nowrap;
  }
  .btn:hover{transform:translateY(-1px); box-shadow:var(--shadow)}
  .btn:active{transform:translateY(0)}
  .btn[aria-pressed="true"]{outline:2px solid var(--accent); background:#18263a}
  .btn.small{padding:8px 10px;border-radius:10px;font-size:12px}
  .btn.ghost{background:transparent}
  .btn.ok{border-color:#1c3b32;background:#0f1e19}
  .btn.warn{border-color:#3a2d12;background:#1a1408}
  .btn.danger{border-color:#3a1212;background:#1a0c0c}
  input[type="file"]{display:none}

  .main{display:grid;grid-template-columns:280px 1fr 320px;gap:12px;padding:12px;min-height:0}
  @media (max-width:1200px){ .main{grid-template-columns:1fr;grid-template-rows:auto 1fr auto;overflow:auto} }

  .panel{
    background:linear-gradient(180deg,var(--card),var(--card2));
    border:1px solid var(--border); border-radius:16px; overflow:auto; min-height:0; box-shadow:inset 0 14px 40px rgba(0,0,0,.25)
  }
  .panel h3{margin:12px 12px 6px;font-size:12px;text-transform:uppercase;letter-spacing:.14em;color:var(--muted)}
  .section{padding:12px;border-top:1px solid #0f1726}
  .row{display:grid;grid-template-columns:1fr 70px;align-items:center;gap:10px;margin:10px 0}
  .label{color:var(--muted);font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .preset-list{display:flex;gap:8px;overflow:auto;padding:8px 12px}

  .viewer{
    position:relative;
    background:
      conic-gradient(from 90deg at 25% 25%, #172538 0 25%, #132034 0 50%, #172538 0 75%, #132034 0 100%) center/24px 24px,
      linear-gradient(180deg,#0b1220,#0b1220);
    border:1px solid var(--border); border-radius:18px; overflow:hidden; min-height:0;
  }
  .dropzone{
    position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
    text-align:center; padding:24px; border:2px dashed #2b3c57; border-radius:14px; color:#bfd4f9; background:rgba(12,19,33,.55);
    pointer-events:none; opacity:0; transform:scale(.97); transition:.18s ease;
  }
  .dropzone.show{opacity:1; transform:scale(1)}
  canvas#preview{position:absolute;top:0;left:0}
  .overlay{position:absolute;inset:0;pointer-events:none}
  .hud{position:absolute;left:12px;bottom:12px;background:#0c1420dd;border:1px solid var(--border);padding:8px 10px;border-radius:10px;color:#c0d1e8;font-size:12px;display:flex;gap:10px;align-items:center;backdrop-filter:blur(6px)}
  .status-dot{width:8px;height:8px;border-radius:50%;background:#38bdf8;box-shadow:0 0 8px #38bdf8}
  .zoom-badge{position:absolute;right:12px;bottom:12px;background:#0c1420dd;border:1px solid var(--border);padding:8px 10px;border-radius:10px;font-size:12px;backdrop-filter:blur(6px)}

  .range{appearance:none;width:100%;height:6px;border-radius:999px;background:#1a2435;outline:none}
  .range::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;
    background:linear-gradient(180deg,#e7f3ff,#a7d4ff);border:1px solid #7bb7ff;box-shadow:0 0 0 4px #132139}
  .val{font-variant-numeric:tabular-nums;text-align:right;color:#cbd8e6}

  .chip{flex:0 0 auto;padding:8px 12px;border:1px solid var(--border);border-radius:999px;cursor:pointer;background:#0f1a2a;color:#cfe3ff;transition:.15s;font-size:12px}
  .chip:hover{background:#15233a}

  .layer-row{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px}
  .layer-row:hover{background:#0f1725}
  .thumb{width:22px;height:22px;border-radius:4px;background:#1b2536;display:inline-block;border:1px solid #223149}
  .note{color:var(--muted);font-size:12px;padding:6px 12px}

  .footer{display:flex;align-items:center;gap:8px;padding:10px 14px;border-top:1px solid var(--border);background:#0b121c}
  .kbd{border:1px solid #2a3648;background:#121b28;padding:2px 6px;border-radius:6px;font-size:12px;color:#c9d7ea}

  .collapsible{border-top:1px solid #0f1726}
  .collapsible summary{
    list-style:none; cursor:pointer; user-select:none;
    padding:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.14em; font-size:12px;
    display:flex; align-items:center; gap:8px;
  }
  .collapsible summary::-webkit-details-marker{display:none}
  .chev{transition:transform .2s ease}
  details[open] summary .chev{transform:rotate(90deg)}
  .collapsible .content{padding:12px; border-top:1px dashed #17233a}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand"><span class="dot"></span>pictr</div>

    <input id="fileInput" type="file"
      accept="image/*,.cr2,.cr3,.nef,.arw,.raf,.dng,.orf,.rw2,.pef,.srw,.kdc,.mrw,.erf" capture="environment" />
    <button id="btnOpen" class="btn" title="Open (O)">➕ Import</button>
    <button id="btnPaste" class="btn ghost small" title="Paste (Ctrl/Cmd+V)">Paste</button>
    <button id="btnDemo" class="btn ghost small" title="Load demo image">Demo</button>

    <div class="spacer"></div>

    <div class="btn-group">
      <button class="btn small" id="toolMove" aria-pressed="true" title="Move (V)">Move</button>
      <button class="btn small" id="toolCrop" title="Crop (C)">Crop</button>
      <button class="btn small" id="toolBrush" title="Brush (B)">Brush</button>
      <button class="btn small" id="toolText" title="Text (T)">Text</button>
      <button class="btn small" id="toolErase" title="Eraser (E)">Erase</button>
    </div>

    <div class="spacer"></div>

    <button class="btn small" id="btnFit" title="Fit (F)">Fit</button>
    <button class="btn small" id="btnZoomOut" title="Zoom Out (–)">–</button>
    <button class="btn small" id="btnZoomIn" title="Zoom In (+)">+</button>
    <button class="btn small ok" id="btnExport" title="Export (E)">Export</button>
  </header>

  <div class="main">
    <!-- LEFT -->
    <div class="panel" aria-label="Quick actions and History">
      <details class="collapsible" open>
        <summary><span class="chev">▶</span> Quick actions</summary>
        <div class="content">
          <div class="grid">
            <button class="btn small" id="qaAuto">Auto</button>
            <button class="btn small" id="qaVivid">Vivid</button>
            <button class="btn small" id="qaBW">B&amp;W</button>
          </div>
          <div class="grid" style="margin-top:8px">
            <button class="btn small" id="rotateL">⟲ 90°</button>
            <button class="btn small" id="rotateR">⟳ 90°</button>
            <button class="btn small" id="resetAll">Reset</button>
          </div>
        </div>
      </details>

      <details class="collapsible" open>
        <summary><span class="chev">▶</span> Presets</summary>
        <div class="content preset-list" id="presets">
          <div class="chip" data-preset="auto">Auto</div>
          <div class="chip" data-preset="vivid">Vivid</div>
          <div class="chip" data-preset="warm">Warm</div>
          <div class="chip" data-preset="cool">Cool</div>
          <div class="chip" data-preset="cinematic">Cinematic</div>
          <div class="chip" data-preset="matte">Matte</div>
          <div class="chip" data-preset="bw">B&amp;W</div>
        </div>
      </details>

      <details class="collapsible" open>
        <summary><span class="chev">▶</span> History</summary>
        <div class="content">
          <div class="grid">
            <button class="btn small" id="snapshot">Add Snapshot</button>
            <button class="btn small" id="revert">Revert</button>
            <button class="btn small" id="clearHistory">Clear</button>
          </div>
          <div id="history" class="section note">No edits yet.</div>
        </div>
      </details>
    </div>

    <!-- CENTER -->
    <div class="viewer" id="viewer" aria-label="Canvas Viewer">
      <div class="dropzone" id="drop">
        <div style="font-size:18px;font-weight:700;margin-bottom:6px">Drop a photo or RAW (CR2/NEF/ARW/DNG…)</div>
        <div class="note" style="padding:0">Or click <b>Import</b> / press <b>Ctrl/Cmd+V</b></div>
      </div>
      <canvas id="preview"></canvas>
      <canvas id="paint" class="overlay"></canvas>
      <canvas id="cropHud" class="overlay"></canvas>
      <div class="hud"><span class="status-dot"></span><span id="hudText">Ready</span></div>
      <div class="zoom-badge"><span id="zoomLabel">100%</span></div>
    </div>

    <!-- RIGHT -->
    <div class="panel" aria-label="Adjustments and Export">
      <details class="collapsible" open>
        <summary><span class="chev">▶</span> Light</summary>
        <div class="content" id="lightSection"></div>
      </details>

      <details class="collapsible" open>
        <summary><span class="chev">▶</span> Color</summary>
        <div class="content" id="colorSection"></div>
      </details>

      <details class="collapsible">
        <summary><span class="chev">▶</span> Detail</summary>
        <div class="content" id="detailSection"></div>
      </details>

      <details class="collapsible">
        <summary><span class="chev">▶</span> Crop</summary>
        <div class="content">
          <div class="grid" style="grid-template-columns:repeat(4,1fr);">
            <button class="btn small" data-ratio="free">Free</button>
            <button class="btn small" data-ratio="1:1">1:1</button>
            <button class="btn small" data-ratio="4:5">4:5</button>
            <button class="btn small" data-ratio="3:2">3:2</button>
            <button class="btn small" data-ratio="16:9">16:9</button>
            <button class="btn small ok" id="applyCrop">Apply</button>
            <button class="btn small ghost" id="cancelCrop">Cancel</button>
          </div>
        </div>
      </details>

      <details class="collapsible">
        <summary><span class="chev">▶</span> Layers</summary>
        <div class="content">
          <div class="layer-row">
            <span class="thumb"></span><span>Image</span><span class="spacer"></span>
            <label class="note"><input id="togglePaint" type="checkbox" checked /> Paint</label>
            <label class="note"><input id="toggleText" type="checkbox" checked /> Text</label>
          </div>
          <div class="note">Brush: size/opacity box at top-right. Eraser removes strokes.</div>
          <div class="grid">
            <button class="btn small" id="clearPaint">Clear Paint</button>
            <button class="btn small" id="addLabel">Add Text Label</button>
          </div>
          <div id="textList" class="section note">No labels yet.</div>
        </div>
      </details>

      <details class="collapsible" open>
        <summary><span class="chev">▶</span> Export</summary>
        <div class="content">
          <div class="row"><div class="label">Format</div>
            <div>
              <select id="fmt" class="btn small" style="width:100%">
                <option value="image/jpeg">JPEG</option>
                <option value="image/png">PNG</option>
                <option value="image/webp">WEBP</option>
              </select>
            </div>
          </div>
          <div class="row"><div class="label">Quality</div>
            <div><input id="quality" type="range" class="range" min="0.5" max="1" step="0.01" value="0.92"></div>
          </div>
          <div class="grid">
            <button class="btn small ok" id="exportNow">Export</button>
            <button class="btn small" id="exportFull">Export Full-Res</button>
          </div>
          <div class="note">Full-Res re-renders at original resolution.</div>
        </div>
      </details>
    </div>
  </div>

  <div class="footer">
    <div class="note">Shortcuts:
      <span class="kbd">V</span> Move
      <span class="kbd">C</span> Crop
      <span class="kbd">B</span> Brush
      <span class="kbd">E</span> Erase
      <span class="kbd">T</span> Text
      <span class="kbd">F</span> Fit
      <span class="kbd">Double-click</span> viewer: Fit/100%
      <span class="kbd">⌘/Ctrl+Z</span> Undo
      <span class="kbd">Shift+⌘/Ctrl+Z</span> Redo
    </div>
  </div>
</div>

<script>
/* ===== Helpers ===== */
const qs = (s,r=document)=>r.querySelector(s);
const clamp=(v,a,b)=>v<a?a:v>b?b:v;
const lerp=(a,b,t)=>a+(b-a)*t;
const fmt2 = (n)=> (Math.round(n*100)/100).toFixed(2);

/* ===== App State ===== */
const DEFAULT_PARAMS = {exposure:0,contrast:0,highlights:0,shadows:0,whites:0,blacks:0,temperature:0,tint:0,
                        vibrance:0.15,saturation:1,clarity:0,sharpness:0,gamma:1,vignette:0};
const S = {
  img:null, imgBitmap:null, origW:0, origH:0,
  rot:0, flipH:false, flipV:false,
  zoom:1, minZoom:.05, maxZoom:8, viewX:0, viewY:0, dragging:false, dragStart:{}, viewStart:{},
  tool:'move',
  brush:{size:26, opacity:.8, hardness:.8, color:'#ffffff'},
  crop:{active:false,x:0,y:0,w:0,h:0,ratio:'free',dragging:false,handle:null,start:{}},
  params:{...DEFAULT_PARAMS},
  labels:[],
  history:[],historyIdx:-1,
  dirty:false,rendering:false,previewScale:1
};

/* ===== Elements ===== */
const els = {
  file: qs('#fileInput'),
  open: qs('#btnOpen'), paste: qs('#btnPaste'), demo: qs('#btnDemo'),
  viewer: qs('#viewer'), drop: qs('#drop'),
  preview: qs('#preview'), paint: qs('#paint'), cropHud: qs('#cropHud'),
  zoomLabel: qs('#zoomLabel'), hudText: qs('#hudText'),
  history: qs('#history'), textList: qs('#textList'),
  fmt: qs('#fmt'), quality: qs('#quality'), presets: qs('#presets'),
  togglePaint: qs('#togglePaint'), toggleText: qs('#toggleText'),
  quick: { auto: qs('#qaAuto'), vivid: qs('#qaVivid'), bw: qs('#qaBW') },
  buttons: {
    move: qs('#toolMove'), crop: qs('#toolCrop'), brush: qs('#toolBrush'), text: qs('#toolText'), erase: qs('#toolErase'),
    fit: qs('#btnFit'), zin: qs('#btnZoomIn'), zout: qs('#btnZoomOut'),
    export: qs('#btnExport'), exportNow: qs('#exportNow'), exportFull: qs('#exportFull'),
    rotateL: qs('#rotateL'), rotateR: qs('#rotateR'), resetAll: qs('#resetAll'),
    applyCrop: qs('#applyCrop'), cancelCrop: qs('#cancelCrop'),
    clearPaint: qs('#clearPaint'), addLabel: qs('#addLabel'),
    snapshot: qs('#snapshot'), revert: qs('#revert'), clearHistory: qs('#clearHistory'),
  }
};
const ctx = els.preview.getContext('2d',{willReadFrequently:true});
const paintCtx = els.paint.getContext('2d',{willReadFrequently:true});
const cropCtx = els.cropHud.getContext('2d');

/* ===== Build Sliders (Light/Color/Detail) ===== */
const LIGHT = [
  {key:'exposure',min:-2,max:2,step:0.01,label:'Exposure (EV)'},
  {key:'contrast',min:-1,max:1,step:0.01,label:'Contrast'},
  {key:'highlights',min:-1,max:1,step:0.01,label:'Highlights'},
  {key:'shadows',min:-1,max:1,step:0.01,label:'Shadows'},
  {key:'whites',min:-1,max:1,step:0.01,label:'Whites'},
  {key:'blacks',min:-1,max:1,step:0.01,label:'Blacks'},
  {key:'gamma',min:0.5,max:2,step:0.01,label:'Gamma'},
  {key:'vignette',min:0,max:1,step:0.01,label:'Vignette'},
];
const COLOR = [
  {key:'temperature',min:-1,max:1,step:0.01,label:'Temperature (Blue↔Warm)'},
  {key:'tint',min:-1,max:1,step:0.01,label:'Tint (Green↔Magenta)'},
  {key:'vibrance',min:0,max:1.5,step:0.01,label:'Vibrance'},
  {key:'saturation',min:0,max:2,step:0.01,label:'Saturation'},
];
const DETAIL = [
  {key:'clarity',min:-1,max:1,step:0.01,label:'Clarity'},
  {key:'sharpness',min:0,max:2,step:0.01,label:'Sharpen'},
];

function buildSliders(sectionId, spec){
  const sec = qs(sectionId); sec.innerHTML='';
  spec.forEach(sp=>{
    const row=document.createElement('div'); row.className='row';
    const label=document.createElement('div'); label.className='label'; label.textContent=sp.label;
    const input=document.createElement('input'); input.type='range'; input.className='range';
    input.min=sp.min; input.max=sp.max; input.step=sp.step; input.value=S.params[sp.key]; input.dataset.key=sp.key;
    const val=document.createElement('div'); val.className='val'; val.innerHTML=`<span id="val-${sp.key}">${fmt2(S.params[sp.key])}</span>`;
    const wrap=document.createElement('div'); wrap.appendChild(input);
    row.appendChild(label); row.appendChild(wrap); row.appendChild(val); sec.appendChild(row);
    input.addEventListener('input',()=>{ const k=input.dataset.key; S.params[k]=Number(input.value); qs(`#val-${k}`).textContent=fmt2(S.params[k]); markDirty(); });
    input.addEventListener('change',()=>pushHistory());
    input.addEventListener('dblclick',()=>{ // reset this slider
      S.params[input.dataset.key] = DEFAULT_PARAMS[input.dataset.key];
      input.value = S.params[input.dataset.key];
      qs(`#val-${input.dataset.key}`).textContent = fmt2(S.params[input.dataset.key]);
      markDirty(); pushHistory();
    });
  });
}
function buildUI(){
  buildSliders('#lightSection', LIGHT);
  buildSliders('#colorSection', COLOR);
  buildSliders('#detailSection', DETAIL);
}
function refreshAllSliderValues(){
  document.querySelectorAll('input.range').forEach(i=>{
    const k=i.dataset.key; i.value=S.params[k];
    const lab=qs(`#val-${k}`); if(lab) lab.textContent=fmt2(S.params[k]);
  });
}

/* ===== Import (Click / DragDrop / Paste) + RAW ===== */
const RAW_EXTS = ['cr2','cr3','nef','arw','raf','dng','orf','rw2','pef','srw','kdc','mrw','erf'];
const extOf=(name='')=>{ const m=/\.([a-z0-9]+)$/i.exec(name||''); return m?m[1].toLowerCase():''; };
const isRawFile=(file)=> RAW_EXTS.includes(extOf(file.name||''));

els.open.addEventListener('click', ()=> els.file.click());
els.file.addEventListener('change', ev=>{
  const f = ev.target.files?.[0]; if (f) loadFile(f); ev.target.value='';
});
['dragenter','dragover'].forEach(evName=>{
  els.viewer.addEventListener(evName, e=>{ e.preventDefault(); e.stopPropagation(); els.drop.classList.add('show'); });
});
['dragleave','drop'].forEach(evName=>{
  els.viewer.addEventListener(evName, e=>{ e.preventDefault(); e.stopPropagation(); els.drop.classList.remove('show'); });
});
els.viewer.addEventListener('drop', e=>{
  const dt=e.dataTransfer; if (dt?.files?.length) loadFile(dt.files[0]);
});
els.paste.addEventListener('click', ()=> setHUD('Press Ctrl/Cmd+V after copying an image.'));
window.addEventListener('paste', (e)=>{
  const items = e.clipboardData?.items || [];
  for (const it of items){
    if (it.type.startsWith('image/')){ const blob = it.getAsFile(); if (blob) loadFile(blob); return; }
  }
  setHUD('No image found on clipboard');
});
els.demo.addEventListener('click', ()=> loadDemoImage());

async function loadFile(file){
  try{
    if (isRawFile(file)){
      const ext = extOf(file.name);
      setHUD(`Reading ${ext.toUpperCase()}… extracting preview`);
      const buf = await file.arrayBuffer();
      let jpegBuf = null;

      if (isTIFF(buf)) jpegBuf = parseTIFFForPreview(buf);
      if (!jpegBuf) jpegBuf = findLargestJPEG(buf); // CR3 or odd cases

      if (!jpegBuf){
        setHUD('No embedded JPEG preview found (or unreadable). For true RAW development (WASM), I can add LibRaw.');
        return;
      }
      await loadFromBlob(new Blob([jpegBuf], {type:'image/jpeg'}), `${ext.toUpperCase()} preview`);
      return;
    }
    await loadFromBlob(file);
  }catch(e){
    console.error(e); setHUD('Failed to load image');
  }
}

async function loadFromBlob(blob, label){
  const url = URL.createObjectURL(blob);
  const img = new Image();
  img.onload = async ()=>{
    URL.revokeObjectURL(url);
    await setBitmapFromImage(img);
    afterImageLoaded();
    setHUD(label ? `Loaded ${label} — ${S.origW}×${S.origH}` : `Loaded ${S.origW}×${S.origH}`);
  };
  img.onerror = async ()=>{
    URL.revokeObjectURL(url);
    if (window.ImageDecoder && blob.type && await ImageDecoder.isTypeSupported(blob.type).catch(()=>false)) {
      try{
        const dec = new ImageDecoder({data: blob, type: blob.type});
        const {image} = await dec.decode();
        const c = document.createElement('canvas'); c.width=image.codedWidth; c.height=image.codedHeight;
        c.getContext('2d').drawImage(image,0,0);
        const fallback = await new Promise(res=> c.toBlob(res,'image/png',0.98));
        if (fallback) return loadFromBlob(fallback, 'decoded');
      }catch(e){}
    }
    setHUD('Unsupported image format in this browser.');
  };
  img.src = url;
}

async function setBitmapFromImage(img){
  S.img = img; S.origW = img.naturalWidth; S.origH = img.naturalHeight;
  if ('createImageBitmap' in window){
    try{ S.imgBitmap = await createImageBitmap(img); } catch { S.imgBitmap = img; }
  } else { S.imgBitmap = img; }
}

function afterImageLoaded(){
  S.params = {...S.params, saturation: (S.params.saturation==null?1:S.params.saturation)};
  resetView(); initCropDefault(); resizeCanvases(); clearPaintLayer();
  S.labels = []; refreshTextList();
  refreshAllSliderValues();
  S.history=[]; S.historyIdx=-1; pushHistory(true); markDirty();
}

/* ===== TIFF/CR2/DNG parser to get embedded JPEG ===== */
function isTIFF(ab){
  if (ab.byteLength<4) return false;
  const u = new Uint8Array(ab,0,4);
  return (u[0]===0x49&&u[1]===0x49&&u[2]===0x2A&&u[3]===0x00) || (u[0]===0x4D&&u[1]===0x4D&&u[2]===0x00&&u[3]===0x2A);
}
function parseTIFFForPreview(ab){
  const u = new DataView(ab);
  const byteOrder = u.getUint16(0,false);
  const little = (byteOrder===0x4949);
  const big = (byteOrder===0x4D4D);
  if (!little && !big) return null;
  const le = little;

  const get16=(o)=>u.getUint16(o,le);
  const get32=(o)=>u.getUint32(o,le);

  const firstIFD = get32(4);
  const visited = new Set();
  let best = null;

  function readValue(tagType, count, valOff){
    const sizeOf = (t)=> t===1||t===2||t===6||t===7 ? 1 : t===3 ? 2 : 4;
    const total = sizeOf(tagType) * count;
    if (total <= 4) {
      if (tagType===4) return [valOff>>>0];
      if (tagType===3) return [valOff & 0xFFFF];
      return [valOff>>>0];
    } else {
      const base = valOff>>>0;
      const arr = [];
      if (tagType===4){ for(let i=0;i<count;i++) arr.push(get32(base+i*4)); }
      else if (tagType===3){ for(let i=0;i<count;i++) arr.push(get16(base+i*2)); }
      return arr;
    }
  }

  function scanIFD(ifdOff){
    if (!ifdOff || visited.has(ifdOff) || ifdOff+2>u.byteLength) return;
    visited.add(ifdOff);
    const num = get16(ifdOff);
    const base = ifdOff + 2;
    const toVisit = [];
    let dngStart=null, dngLen=null, jfifOff=null, jfifLen=null;

    for (let i=0;i<num;i++){
      const e = base + i*12;
      if (e+12 > u.byteLength) break;
      const tag = get16(e);
      const type = get16(e+2);
      const count= get32(e+4);
      const val  = get32(e+8);

      if (tag===0x014A){ const offs = readValue(type,count,val); offs.forEach(o=>{ if(o) toVisit.push(o); }); }       // SubIFDs
      if (tag===0x8769){ toVisit.push(val); }                                                                           // ExifIFDPointer
      if (tag===0xC6F0) dngStart = readValue(type,count,val)[0];                                                        // DNG PreviewImageStart
      if (tag===0xC6F1) dngLen   = readValue(type,count,val)[0];                                                        // DNG PreviewImageLength
      if (tag===0x0201) jfifOff  = readValue(type,count,val)[0];                                                        // JPEGInterchangeFormat
      if (tag===0x0202) jfifLen  = readValue(type,count,val)[0];                                                        // JPEGInterchangeFormatLength
    }

    const addCandidate=(off,len)=>{
      if (!off || !len) return;
      if (off+len > u.byteLength) return;
      const size=len;
      if (!best || size>best.size) best = {off,len,size};
    };
    addCandidate(dngStart,dngLen);
    addCandidate(jfifOff,jfifLen);

    const nextIFD = get32(base + num*12);
    if (nextIFD) toVisit.push(nextIFD);
    toVisit.forEach(o=> scanIFD(o));
  }

  scanIFD(firstIFD);
  if (best){
    const a = new Uint8Array(ab, best.off, best.len);
    if (a[0]===0xFF && a[1]===0xD8) return ab.slice(best.off, best.off+best.len);
    const idx = findEOI(a);
    if (idx>2) return ab.slice(best.off, best.off+idx);
  }
  return null;
}
function findEOI(u8){ for(let i=u8.length-2;i>=2;i--){ if (u8[i]===0xFF && u8[i+1]===0xD9) return i+2; } return -1; }
function findLargestJPEG(buf){
  const u = new Uint8Array(buf);
  let i=0, best=null;
  while (i<u.length-1){
    if (u[i]===0xFF && u[i+1]===0xD8){
      let start=i; let j=i+2; let end=-1;
      while (j<u.length-1){
        if (u[j]===0xFF && u[j+1]===0xD9){ end=j+2; break; }
        j++;
      }
      if (end>0){
        const size=end-start; if (!best || size>best.size) best={start,end,size}; i=end; continue;
      } else break;
    }
    i++;
  }
  return best ? buf.slice(best.start,best.end) : null;
}

/* ===== Viewer sizing, zoom, and quality ===== */
function resizeCanvases(){
  const rect=els.viewer.getBoundingClientRect(); const dpr=window.devicePixelRatio||1;
  [els.preview,els.paint,els.cropHud].forEach(c=>{
    c.width=Math.floor(rect.width*dpr); c.height=Math.floor(rect.height*dpr);
    c.style.width=rect.width+'px'; c.style.height=rect.height+'px';
    const g=c.getContext('2d'); g.setTransform(1,0,0,1,0,0); g.scale(dpr,dpr);
  });
  updateZoomBadge(); markDirty(); drawPaintLayer(); drawCropHUD();
}
window.addEventListener('resize', resizeCanvases);

function resetView(){ S.zoom=1; S.viewX=0; S.viewY=0; fitToScreen(); }
function fitToScreen(){
  if(!S.imgBitmap) return;
  const rect=els.viewer.getBoundingClientRect();
  const margin=40; const tw=rect.width-margin, th=rect.height-margin;
  let iw=S.origW, ih=S.origH; if(S.rot%180!==0) [iw,ih]=[ih,iw];
  const scale=Math.min(tw/iw, th/ih);
  S.zoom=clamp(scale, S.minZoom, S.maxZoom);
  S.viewX=(rect.width - iw*S.zoom)/2; S.viewY=(rect.height - ih*S.zoom)/2;
  updateZoomBadge(); markDirty();
}
function updateZoomBadge(){ els.zoomLabel.textContent=Math.round(S.zoom*100)+'%'; }

function pointerPos(ev, el){
  const r=el.getBoundingClientRect(); const t=(ev.touches&&ev.touches[0])||ev.changedTouches?.[0]||ev;
  return {x:t.clientX-r.left, y:t.clientY-r.top};
}
els.viewer.addEventListener('wheel', (e)=>{
  e.preventDefault(); if(!S.imgBitmap) return;
  const delta=-Math.sign(e.deltaY)*0.12; const prev=S.zoom;
  S.zoom=clamp(S.zoom*(1+delta), S.minZoom,S.maxZoom);
  const rect=els.viewer.getBoundingClientRect(); const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
  const sx=(cx-S.viewX)/prev, sy=(cy-S.viewY)/prev;
  S.viewX=cx - sx*S.zoom; S.viewY=cy - sy*S.zoom; updateZoomBadge(); markDirty();
},{passive:false});
els.viewer.addEventListener('dblclick', ()=>{
  if (!S.imgBitmap) return;
  if (Math.abs(S.zoom-1)<0.01) fitToScreen();
  else { // toggle to 100%
    const rect=els.viewer.getBoundingClientRect();
    let iw=S.origW, ih=S.origH; if(S.rot%180!==0) [iw,ih]=[ih,iw];
    S.zoom=1; S.viewX=(rect.width - iw*S.zoom)/2; S.viewY=(rect.height - ih*S.zoom)/2;
    updateZoomBadge(); markDirty();
  }
});

/* ===== Interactions ===== */
['mousedown','touchstart'].forEach(type=>{
  els.viewer.addEventListener(type,(ev)=>{
    const p=pointerPos(ev,els.viewer);
    if(S.tool==='move'){ S.dragging=true; S.dragStart=p; S.viewStart={x:S.viewX,y:S.viewY}; }
    else if(S.tool==='brush'||S.tool==='erase'){ startStroke(p); }
    else if(S.tool==='crop'){ cropPointerDown(p); }
    else if(S.tool==='text'){ createOrSelectLabel(p); }
  });
});
['mousemove','touchmove'].forEach(type=>{
  els.viewer.addEventListener(type,(ev)=>{
    const p=pointerPos(ev,els.viewer);
    if(S.tool==='move'&&S.dragging){ S.viewX=S.viewStart.x+(p.x-S.dragStart.x); S.viewY=S.viewStart.y+(p.y-S.dragStart.y); markDirty(); }
    else if((S.tool==='brush'||S.tool==='erase')&&stroke.active){ continueStroke(p); }
    else if(S.tool==='crop'&&S.crop.active){ cropPointerMove(p); }
    else if(S.tool==='text'&&draggingLabel){ moveLabel(p); }
  });
});
['mouseup','mouseleave','touchend','touchcancel'].forEach(type=>{
  els.viewer.addEventListener(type,()=>{
    if(S.tool==='move') S.dragging=false;
    if((S.tool==='brush'||S.tool==='erase')&&stroke.active) endStroke();
    if(S.tool==='crop'&&S.crop.dragging) cropPointerUp();
    if(S.tool==='text'&&draggingLabel){ draggingLabel=false; pushHistory(); }
  });
});

/* ===== Tool & Buttons ===== */
function setTool(tool){
  S.tool=tool;
  for (const [k,btn] of Object.entries({move:els.buttons.move,crop:els.buttons.crop,brush:els.buttons.brush,text:els.buttons.text,erase:els.buttons.erase})){
    btn.setAttribute('aria-pressed', k===tool?'true':'false');
  }
  if (tool==='crop'){ S.crop.active=true; drawCropHUD(); setHUD('Crop: drag handles, then Apply.'); }
  else { S.crop.dragging=false; drawCropHUD(); }
}
els.buttons.move.onclick=()=>setTool('move');
els.buttons.crop.onclick=()=>setTool('crop');
els.buttons.brush.onclick=()=>setTool('brush');
els.buttons.erase.onclick=()=>setTool('erase');
els.buttons.text.onclick=()=>setTool('text');
els.buttons.fit.onclick=()=>fitToScreen();
els.buttons.zin.onclick=()=>{ S.zoom=clamp(S.zoom*1.18,S.minZoom,S.maxZoom); updateZoomBadge(); markDirty(); }
els.buttons.zout.onclick=()=>{ S.zoom=clamp(S.zoom/1.18,S.minZoom,S.maxZoom); updateZoomBadge(); markDirty(); }
els.buttons.export.onclick=()=>doExport(false);
els.buttons.exportNow.onclick=()=>doExport(false);
els.buttons.exportFull.onclick=()=>doExport(true);
els.buttons.rotateL.onclick=()=>{ S.rot=(S.rot-90+360)%360; markDirty(); pushHistory(); }
els.buttons.rotateR.onclick=()=>{ S.rot=(S.rot+90)%360; markDirty(); pushHistory(); }
els.buttons.resetAll.onclick=()=>{
  if(!S.imgBitmap) return;
  S.params={...DEFAULT_PARAMS}; S.rot=0; S.flipH=false; S.flipV=false;
  resetView(); initCropDefault(); clearPaintLayer(); S.labels=[]; refreshTextList(); refreshAllSliderValues(); markDirty(); pushHistory();
};

/* Keyboard */
window.addEventListener('keydown',(e)=>{
  if(e.key==='v'||e.key==='V') setTool('move');
  else if(e.key==='c'||e.key==='C') setTool('crop');
  else if(e.key==='b'||e.key==='B') setTool('brush');
  else if(e.key==='e'||e.key==='E') setTool('erase');
  else if(e.key==='t'||e.key==='T') setTool('text');
  else if(e.key==='f'||e.key==='F') els.buttons.fit.click();
  else if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); undo(); }
  else if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z' && e.shiftKey){ e.preventDefault(); redo(); }
  else if(e.key==='+'||e.key==='='){ els.buttons.zin.click(); }
  else if(e.key==='-'||e.key==='_'){ els.buttons.zout.click(); }
});

/* ===== HUD & History ===== */
function setHUD(t){ els.hudText.textContent=t; }
function snapshotState(){
  return JSON.stringify({params:S.params,rot:S.rot,flipH:S.flipH,flipV:S.flipV,
    crop:S.crop.active?{...S.crop}:{active:false,x:0,y:0,w:0,h:0,ratio:'free'},labels:S.labels,paint:els.paint.toDataURL()});
}
function restoreState(json){
  const obj=JSON.parse(json);
  Object.assign(S.params, obj.params||{}); S.rot=obj.rot||0; S.flipH=!!obj.flipH; S.flipV=!!obj.flipV;
  S.crop=obj.crop||{active:false,x:0,y:0,w:0,h:0,ratio:'free'}; S.labels=obj.labels||[];
  loadPaintFromDataURL(obj.paint); refreshTextList(); refreshAllSliderValues(); markDirty();
}
function pushHistory(initial=false){
  if(!S.imgBitmap) return;
  if (S.historyIdx < S.history.length-1) S.history = S.history.slice(0,S.historyIdx+1);
  S.history.push(snapshotState()); S.historyIdx=S.history.length-1; renderHistoryList();
  if(!initial) setHUD('Edit saved');
}
function undo(){ if(S.historyIdx>0){ S.historyIdx--; restoreState(S.history[S.historyIdx]); renderHistoryList(); setHUD('Undid'); } }
function redo(){ if(S.historyIdx<S.history.length-1){ S.historyIdx++; restoreState(S.history[S.historyIdx]); renderHistoryList(); setHUD('Redid'); } }
els.buttons.snapshot.onclick=()=>pushHistory();
els.buttons.revert.onclick=()=>{ if(!S.history.length) return; S.historyIdx=0; restoreState(S.history[0]); renderHistoryList(); setHUD('Reverted'); };
els.buttons.clearHistory.onclick=()=>{ S.history=[]; S.historyIdx=-1; renderHistoryList(); setHUD('History cleared'); };

function renderHistoryList(){
  if(!S.history.length){ els.history.textContent='No edits yet.'; return; }
  els.history.innerHTML='';
  S.history.forEach((_,i)=>{
    const b=document.createElement('button'); b.className='btn small'+(i===S.historyIdx?' ok':'');
    b.textContent=i===0?'Original':`Step ${i}`; b.onclick=()=>{ S.historyIdx=i; restoreState(S.history[i]); renderHistoryList(); };
    els.history.appendChild(b);
  });
}

/* ===== Presets & Quick actions ===== */
const presetMap = {
  auto:p=>({...p,exposure:p.exposure+0.2,contrast:p.contrast+0.15,highlights:-0.15,shadows:0.2,whites:0.05,blacks:-0.05,vibrance:0.25,sharpness:0.2}),
  vivid:p=>({...p,vibrance:0.55,saturation:1.2,contrast:p.contrast+0.18,clarity:p.clarity+0.12}),
  warm:p=>({...p,temperature:0.35,tint:0.05,vibrance:0.2}),
  cool:p=>({...p,temperature:-0.25,tint:-0.05,vibrance:0.2}),
  cinematic:p=>({...p,contrast:p.contrast+0.25,highlights:-0.2,shadows:0.18,saturation:0.9,vibrance:0.3,gamma:0.96,vignette:0.25}),
  matte:p=>({...p,blacks:0.15,contrast:p.contrast-0.05,gamma:1.05,saturation:0.92}),
  bw:p=>({...p,saturation:0,vibrance:0,contrast:p.contrast+0.22,clarity:p.clarity+0.12}),
};
els.presets.addEventListener('click',(e)=>{
  const chip=e.target.closest('.chip'); if(!chip) return; if(!S.imgBitmap){ setHUD('Open a photo first'); return; }
  S.params=presetMap[chip.dataset.preset](S.params); refreshAllSliderValues(); markDirty(); pushHistory(); setHUD(`Preset: ${chip.dataset.preset}`);
});
els.quick.auto.onclick = ()=>{ if(!S.imgBitmap) return setHUD('Open a photo first'); S.params=presetMap.auto(S.params); refreshAllSliderValues(); markDirty(); pushHistory(); };
els.quick.vivid.onclick=()=>{ if(!S.imgBitmap) return setHUD('Open a photo first'); S.params=presetMap.vivid(S.params); refreshAllSliderValues(); markDirty(); pushHistory(); };
els.quick.bw.onclick   =()=>{ if(!S.imgBitmap) return setHUD('Open a photo first'); S.params=presetMap.bw(S.params);    refreshAllSliderValues(); markDirty(); pushHistory(); };

/* ===== Crop ===== */
function initCropDefault(){
  const r=imageRectOnScreen(); if(!r) return;
  const m=.1; S.crop={active:false,x:r.x+r.w*m,y:r.y+r.h*m,w:r.w*(1-2*m),h:r.h*(1-2*m),ratio:'free',dragging:false,handle:null,start:{}};
  drawCropHUD();
}
function imageRectOnScreen(){
  if(!S.imgBitmap) return null; let iw=S.origW, ih=S.origH; if(S.rot%180!==0) [iw,ih]=[ih,iw];
  return {x:S.viewX,y:S.viewY,w:iw*S.zoom,h:ih*S.zoom};
}
function drawCropHUD(){
  const g=cropCtx; const {width:W,height:H}=els.cropHud;
  g.clearRect(0,0,W,H); if(!S.crop.active) return;
  g.save(); g.scale(devicePixelRatio||1, devicePixelRatio||1);
  const r={x:S.crop.x,y:S.crop.y,w:S.crop.w,h:S.crop.h};
  g.fillStyle='rgba(0,0,0,.45)'; g.fillRect(0,0,W,H); g.clearRect(r.x,r.y,r.w,r.h);
  g.strokeStyle='#a8d5ff'; g.lineWidth=2; g.strokeRect(r.x+.5,r.y+.5,r.w-1,r.h-1);
  g.strokeStyle='rgba(168,213,255,.6)'; g.lineWidth=1;
  for(let i=1;i<=2;i++){ g.beginPath(); g.moveTo(r.x+r.w*i/3,r.y); g.lineTo(r.x+r.w*i/3,r.y+r.h); g.stroke();
    g.beginPath(); g.moveTo(r.x, r.y+r.h*i/3); g.lineTo(r.x+r.w,r.y+r.h*i/3); g.stroke(); }
  const s=12, hs=[
    {name:'nw',x:r.x-s/2,y:r.y-s/2},{name:'n',x:r.x+r.w/2-s/2,y:r.y-s/2},{name:'ne',x:r.x+r.w-s/2,y:r.y-s/2},
    {name:'e',x:r.x+r.w-s/2,y:r.y+r.h/2-s/2},{name:'se',x:r.x+r.w-s/2,y:r.y+r.h-s/2},
    {name:'s',x:r.x+r.w/2-s/2,y:r.y+r.h-s/2},{name:'sw',x:r.x-s/2,y:r.y+r.h-s/2},{name:'w',x:r.x-s/2,y:r.y+r.h/2-s/2}
  ];
  g.fillStyle='#dbeafe'; g.strokeStyle='#7bb7ff';
  hs.forEach(h=>{ g.beginPath(); g.rect(h.x,h.y,s,s); g.fill(); g.stroke(); });
  g.restore();
}
function cropHandles(){
  const s=12, r=S.crop; return [
    {name:'nw',x:r.x-s/2,y:r.y-s/2,s},{name:'n',x:r.x+r.w/2-s/2,y:r.y-s/2,s},{name:'ne',x:r.x+r.w-s/2,y:r.y-s/2,s},
    {name:'e',x:r.x+r.w-s/2,y:r.y+r.h/2-s/2,s},{name:'se',x:r.x+r.w-s/2,y:r.y+r.h-s/2,s},
    {name:'s',x:r.x+r.w/2-s/2,y:r.y+r.h-s/2,s},{name:'sw',x:r.x-s/2,y:r.y+r.h-s/2,s},{name:'w',x:r.x-s/2,y:r.y+r.h/2-s/2,s}
  ];
}
function hitHandle(p){return cropHandles().find(h=> p.x>=h.x&&p.x<=h.x+h.s&&p.y>=h.y&&p.y<=h.y+h.s )}
function cropPointerDown(p){ if(!S.crop.active) return; const hh=hitHandle(p); S.crop.dragging=true; S.crop.handle=hh?hh.name:'move'; S.crop.start={x:S.crop.x,y:S.crop.y,w:S.crop.w,h:S.crop.h,px:p.x,py:p.y}; }
function cropPointerMove(p){
  const r=S.crop, s=S.crop.start, ratio=S.crop.ratio, dx=p.x-s.px, dy=p.y-s.py;
  if(S.crop.handle==='move'){ r.x=s.x+dx; r.y=s.y+dy; }
  else{
    let x=s.x,y=s.y,w=s.w,h=s.h; const aspect=ratio==='free'?null:(()=>{const[a,b]=ratio.split(':').map(Number);return a/b})();
    const applyAspect=(edge)=>{ if(!aspect) return; if(edge==='e'||edge==='w'){ h=w/aspect; } else if(edge==='n'||edge==='s'){ w=h*aspect; } };
    if(['nw','w','sw'].includes(S.crop.handle)){ x=s.x+dx; w=s.w-dx; applyAspect('w'); }
    if(['ne','e','se'].includes(S.crop.handle)){ w=s.w+dx; applyAspect('e'); }
    if(['nw','n','ne'].includes(S.crop.handle)){ y=s.y+dy; h=s.h-dy; applyAspect('n'); }
    if(['sw','s','se'].includes(S.crop.handle)){ h=s.h+dy; applyAspect('s'); }
    w=Math.max(20,w); h=Math.max(20,h); r.x=x; r.y=y; r.w=w; r.h=h;
  }
  drawCropHUD();
}
function cropPointerUp(){ S.crop.dragging=false; pushHistory(); }
qs('.panel[aria-label="Adjustments and Export"]').addEventListener('click',(e)=>{
  const b=e.target.closest('.btn'); if(!b) return; const r=b.dataset.ratio; if(!r) return;
  S.crop.ratio=r;
  if(S.crop.active&&r!=='free'){
    const[a,b2]=r.split(':').map(Number); const aspect=a/b2;
    const cx=S.crop.x+S.crop.w/2, cy=S.crop.y+S.crop.h/2; let w=S.crop.w, h=w/aspect;
    if(h>S.crop.h){ h=S.crop.h; w=h*aspect; }
    S.crop.x=cx-w/2; S.crop.y=cy-h/2; S.crop.w=w; S.crop.h=h; drawCropHUD();
  }
});
els.buttons.applyCrop.onclick=()=>{
  if(!S.imgBitmap||!S.crop.active) return;
  const rect=imageRectOnScreen();
  const ix=(S.crop.x-rect.x)/S.zoom, iy=(S.crop.y-rect.y)/S.zoom, iw=S.crop.w/S.zoom, ih=S.crop.h/S.zoom;
  const off=document.createElement('canvas'), g=off.getContext('2d'); off.width=Math.max(1,Math.round(iw)); off.height=Math.max(1,Math.round(ih));
  g.save(); applyImageTransforms(g,-ix,-iy); g.drawImage(S.imgBitmap,0,0); g.restore();
  const img=new Image(); img.onload=async()=>{ await setBitmapFromImage(img); afterImageLoaded(); setHUD('Crop applied'); }; img.src=off.toDataURL();
};
els.buttons.cancelCrop.onclick=()=>{ S.crop.active=false; drawCropHUD(); setTool('move'); };

/* ===== Paint ===== */
function clearPaintLayer(){ paintCtx.clearRect(0,0,els.paint.width,els.paint.height); drawPaintLayer(); }
els.buttons.clearPaint.onclick=()=>{ clearPaintLayer(); pushHistory(); };
let stroke={active:false,last:null};
function startStroke(p){ if(!S.imgBitmap){ setHUD('Open a photo first'); return; } stroke.active=true; stroke.last=p; drawBrushDot(p,true); }
function continueStroke(p){ drawBrushLine(stroke.last,p); stroke.last=p; }
function endStroke(){ stroke.active=false; pushHistory(); }
function drawBrushDot(p){
  const g=paintCtx, size=S.brush.size;
  g.save(); g.globalAlpha=S.brush.opacity; g.globalCompositeOperation=(S.tool==='erase')?'destination-out':'source-over';
  g.beginPath(); g.arc(p.x,p.y,size/2,0,Math.PI*2);
  const grd=g.createRadialGradient(p.x,p.y,0,p.x,p.y,size/2); const hard=clamp(S.brush.hardness,0,1);
  grd.addColorStop(0, S.tool==='erase' ? 'rgba(0,0,0,1)' : S.brush.color);
  grd.addColorStop(hard, S.tool==='erase' ? 'rgba(0,0,0,1)' : S.brush.color);
  grd.addColorStop(1, S.tool==='erase' ? 'rgba(0,0,0,0)' : S.brush.color+'00');
  g.fillStyle=grd; g.fill(); g.restore(); drawPaintLayer();
}
function drawBrushLine(a,b){
  const dist=Math.hypot(b.x-a.x,b.y-a.y); const steps=Math.ceil(dist/(S.brush.size*0.3));
  for(let i=1;i<=steps;i++){ const t=i/steps; drawBrushDot({x:lerp(a.x,b.x,t), y:lerp(a.y,b.y,t)}); }
}
function drawPaintLayer(){}

/* ===== Text ===== */
let draggingLabel=null;
function createOrSelectLabel(p){
  const hit=S.labels.findLast(l=>{ const w=l.size*l.text.length*0.6, h=l.size*1.2; return p.x>=l.x&&p.x<=l.x+w&&p.y>=l.y-h&&p.y<=l.y; });
  if(hit){ draggingLabel=hit; return; }
  const text=prompt('Label text:','Your text'); if(!text) return;
  S.labels.push({id:Date.now().toString(36),text,x:p.x,y:p.y,size:28,fill:'#ffffff',opacity:1});
  refreshTextList(); markDirty(); pushHistory();
}
function moveLabel(p){ if(!draggingLabel) return; draggingLabel.x=p.x; draggingLabel.y=p.y; markDirty(); }
function refreshTextList(){
  if(!S.labels.length){ els.textList.textContent='No labels yet.'; return; }
  els.textList.innerHTML='';
  S.labels.forEach(l=>{
    const row=document.createElement('div'); row.className='layer-row';
    row.innerHTML=`<div class="thumb"></div>
      <input value="${l.text}" style="flex:1;background:#0b121c;color:#e6edf7;border:1px solid #1e2a3a;border-radius:6px;padding:6px 8px" />
      <input type="color" value="${l.fill}" />
      <input type="range" min="10" max="120" step="1" value="${l.size}" class="range" />
      <input type="range" min="0.1" max="1" step="0.01" value="${l.opacity}" class="range" />
      <button class="btn small danger">Delete</button>`;
    const [txt,color,size,op,del]=row.querySelectorAll('input,button');
    txt.oninput=()=>{ l.text=txt.value; markDirty(); };
    color.oninput=()=>{ l.fill=color.value; markDirty(); };
    size.oninput=()=>{ l.size=Number(size.value); markDirty(); };
    op.oninput=()=>{ l.opacity=Number(op.value); markDirty(); };
    del.onclick=()=>{ S.labels=S.labels.filter(x=>x.id!==l.id); refreshTextList(); markDirty(); pushHistory(); };
    els.textList.appendChild(row);
  });
}
function drawLabelsOnScreen(g, labels){
  if(!labels.length||!els.toggleText.checked) return;
  g.save(); labels.forEach(l=>{ g.globalAlpha=l.opacity; g.fillStyle=l.fill; g.font=`600 ${l.size}px Inter, system-ui, Arial`; g.textBaseline='alphabetic'; g.fillText(l.text,l.x,l.y); }); g.restore();
}

/* ===== Render (HiDPI + 1:1 crisp rule) ===== */
function markDirty(){ S.dirty=true; if(!S.rendering){ S.rendering=true; requestAnimationFrame(()=>{ render(); S.rendering=false; }); } }
function render(){
  S.dirty=false; const g=ctx; const rect=els.viewer.getBoundingClientRect();
  g.clearRect(0,0,rect.width,rect.height);
  if(!S.imgBitmap){
    g.save(); g.fillStyle='#0c1420'; g.fillRect(0,0,rect.width,rect.height);
    g.fillStyle='#9fb7d6'; g.textAlign='center'; g.font='600 16px Inter, system-ui'; g.fillText('Drop an image / click Import / Paste', rect.width/2, rect.height/2); g.restore();
    return;
  }
  g.save(); g.imageSmoothingEnabled=true; g.imageSmoothingQuality='high';
  g.translate(S.viewX,S.viewY); g.scale(S.zoom,S.zoom); applyImageTransforms(g,0,0); drawWithPipeline(g,S.imgBitmap,S.params,false); g.restore();
  drawLabelsOnScreen(ctx,S.labels); drawCropHUD();
}
function applyImageTransforms(g,ox,oy){
  let w=S.origW,h=S.origH; g.translate(ox,oy); g.translate(w/2,h/2); g.scale(S.flipH?-1:1,S.flipV?-1:1); g.rotate(S.rot*Math.PI/180);
  if(S.rot%180!==0) [w,h]=[h,w]; g.translate(-w/2,-h/2);
}
function computePreviewScale(w,h){
  const rect = els.viewer.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const maxPreview = Math.max(rect.width, rect.height) * 1.25 * dpr;
  const scale = Math.min(1, maxPreview / Math.max(w, h));
  S.previewScale = scale;
  return scale;
}
function drawWithPipeline(g, bitmap, p, fullRes=false){
  const vw=S.origW, vh=S.origH;
  const scale = fullRes ? 1 : (S.zoom >= 1 ? 1 : computePreviewScale(vw, vh));
  const sw=Math.max(1,Math.round(vw*scale)), sh=Math.max(1,Math.round(vh*scale));
  const off=document.createElement('canvas'); off.width=sw; off.height=sh; const x=off.getContext('2d',{willReadFrequently:true});
  x.imageSmoothingEnabled=true; x.imageSmoothingQuality='high'; x.drawImage(bitmap,0,0,sw,sh);
  let img=x.getImageData(0,0,sw,sh);
  img=passBasic(img,p); img=passHighlightsShadows(img,p.highlights,p.shadows);
  img=passVibranceSaturation(img,p.vibrance,(p.saturation??1));
  if(Math.abs(p.clarity)>0.001) img=passClarity(img,p.clarity);
  if(p.sharpness>0.001) img=passSharpen(img,p.sharpness);
  x.putImageData(img,0,0);
  g.drawImage(off,0,0,vw,vh);
  if(p.vignette>0.001){
    const grad=g.createRadialGradient(vw/2,vh/2,Math.min(vw,vh)*0.25,vw/2,vh/2,Math.max(vw,vh)*0.65);
    grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,`rgba(0,0,0,${clamp(p.vignette,0,1)})`);
    g.fillStyle=grad; g.fillRect(0,0,vw,vh);
  }
}

/* ===== Passes ===== */
function passBasic(imageData,p){
  const d=imageData.data,L=d.length; const gain=Math.pow(2,p.exposure||0), c=p.contrast||0, whites=p.whites||0, blacks=p.blacks||0, gamma=p.gamma||1;
  const t=p.temperature||0, ti=p.tint||0; const rMul=1+t*0.3+ti*0.05, gMul=1-ti*0.07, bMul=1-t*0.3-ti*0.05;
  const k=(1+c), kc=0.5*(1-k); const bCut=clamp(-blacks,0,0.4), wCut=clamp(whites>0?whites*0.3:0,0,0.4);
  for(let i=0;i<L;i+=4){
    let r=d[i]/255, g=d[i+1]/255, b=d[i+2]/255;
    r*=rMul*gain; g*=gMul*gain; b*=bMul*gain;
    r=(r-bCut)/(1-bCut-wCut); g=(g-bCut)/(1-bCut-wCut); b=(b-bCut)/(1-bCut-wCut);
    r=r*k+kc; g=g*k+kc; b=b*k+kc;
    r=Math.pow(clamp(r,0,1),1/gamma); g=Math.pow(clamp(g,0,1),1/gamma); b=Math.pow(clamp(b,0,1),1/gamma);
    d[i]=r*255; d[i+1]=g*255; d[i+2]=b*255;
  } return imageData;
}
function passHighlightsShadows(imageData,highlights,shadows){
  if(Math.abs(highlights)<.001 && Math.abs(shadows)<.001) return imageData; const d=imageData.data;
  for(let i=0;i<d.length;i+=4){
    let r=d[i]/255,g=d[i+1]/255,b=d[i+2]/255; const L=.2126*r+.7152*g+.0722*b; let R=r,G=g,B=b;
    if(shadows>0 && L<.5){ const t=shadows*(1-L*2); R=r+(r*.6+.05-r)*t; G=g+(g*.6+.05-g)*t; B=b+(b*.6+.05-b)*t; }
    else if(shadows<0 && L<.5){ const t=-shadows*(1-L*2); R=r*(1-.6*t); G=g*(1-.6*t); B=b*(1-.6*t); }
    if(highlights<0 && L>.5){ const t=-highlights*((L-.5)*2); const mid=.9; R=R-(R-mid)*t; G=G-(G-mid)*t; B=B-(B-mid)*t; }
    else if(highlights>0 && L>.5){ const t=highlights*((L-.5)*2); R=R+(1-R)*.2*t; G=G+(1-G)*.2*t; B=B+(1-B)*.2*t; }
    d[i]=clamp(R,0,1)*255; d[i+1]=clamp(G,0,1)*255; d[i+2]=clamp(B,0,1)*255;
  } return imageData;
}
function rgb2hsl(r,g,b){ const max=Math.max(r,g,b),min=Math.min(r,g,b); let h,s,l=(max+min)/2;
  if(max===min){h=s=0}else{const d=max-min; s=l>0.5?d/(2-max-min):d/(max+min); switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break} h/=6 } return [h,s,l];}
function hsl2rgb(h,s,l){ if(s===0) return [l,l,l]; const hue2rgb=(p,q,t)=>{ if(t<0)t+=1; if(t>1)t-=1; if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q; if(t<2/3)return p+(q-p)*(2/3-t)*6; return p; };
  const q=l<.5?l*(1+s):l+s-l*s, p=2*l-q; return [hue2rgb(p,q,h+1/3),hue2rgb(p,q,h),hue2rgb(p,q,h-1/3)]; }
function passVibranceSaturation(imageData,vibrance,saturation){
  const sat = (saturation==null?1:saturation);
  const d=imageData.data; for(let i=0;i<d.length;i+=4){
    let r=d[i]/255,g=d[i+1]/255,b=d[i+2]/255; let[h,s,l]=rgb2hsl(r,g,b);
    const add=(vibrance||0)*(1-s);
    s=clamp(s*sat+add,0,1.2);
    [r,g,b]=hsl2rgb(h,s,l);
    d[i]=clamp(r,0,1)*255; d[i+1]=clamp(g,0,1)*255; d[i+2]=clamp(b,0,1)*255;
  } return imageData;
}
function boxBlur(src,w,h,radius){
  const dst=new Uint8ClampedArray(src.length), tmp=new Uint8ClampedArray(src.length); const r=Math.max(1,Math.floor(radius)), div=(2*r+1);
  for(let y=0;y<h;y++){ let sumR=0,sumG=0,sumB=0,sumA=0; let yi=y*w*4, ti=yi;
    for(let i=-r;i<=r;i++){ const xi=clamp(i,0,w-1)*4+yi; sumR+=src[xi]; sumG+=src[xi+1]; sumB+=src[xi+2]; sumA+=src[xi+3]; }
    for(let x=0;x<w;x++){ tmp[ti]=sumR/div; tmp[ti+1]=sumG/div; tmp[ti+2]=sumB/div; tmp[ti+3]=sumA/div;
      const remove=clamp(x-r,0,w-1)*4+yi, add=clamp(x+r+1,0,w-1)*4+yi;
      sumR+=src[add]-src[remove]; sumG+=src[add+1]-src[remove+1]; sumB+=src[add+2]-src[remove+2]; sumA+=src[add+3]-src[remove+3]; ti+=4; }
  }
  for(let x=0;x<w;x++){ let sumR=0,sumG=0,sumB=0,sumA=0; let ti=x*4;
    for(let i=-r;i<=r;i++){ const yi=(clamp(i,0,h-1)*w*4)+ti; sumR+=tmp[yi]; sumG+=tmp[yi+1]; sumB+=tmp[yi+2]; sumA+=tmp[yi+3]; }
    for(let y=0;y<h;y++){ const di=y*w*4+x*4; dst[di]=sumR/div; dst[di+1]=sumG/div; dst[di+2]=sumB/div; dst[di+3]=sumA/div;
      const remove=(clamp(y-r,0,h-1)*w*4)+x*4, add=(clamp(y+r+1,0,h-1)*w*4)+x*4;
      sumR+=tmp[add]-tmp[remove]; sumG+=tmp[add+1]-tmp[remove+1]; sumB+=tmp[add+2]-tmp[remove+2]; sumA+=tmp[add+3]-tmp[remove+3]; }
  }
  return dst;
}
function passClarity(imageData,amount){
  const w=imageData.width,h=imageData.height,d=imageData.data; const blurred=boxBlur(d,w,h,2);
  for(let i=0;i<d.length;i+=4){ const dr=d[i]-blurred[i], dg=d[i+1]-blurred[i+1], db=d[i+2]-blurred[i+2];
    d[i]=clamp((d[i]+dr*amount*1.5)/255,0,1)*255; d[i+1]=clamp((d[i+1]+dg*amount*1.5)/255,0,1)*255; d[i+2]=clamp((d[i+2]+db*amount*1.5)/255,0,1)*255; }
  return imageData;
}
function passSharpen(imageData,amount){
  const w=imageData.width,h=imageData.height,d=imageData.data; const blurred=boxBlur(d,w,h,1), amt=amount*1.2;
  for(let i=0;i<d.length;i+=4){ const usR=d[i]-blurred[i], usG=d[i+1]-blurred[i+1], usB=d[i+2]-blurred[i+2];
    d[i]=clamp((d[i]+usR*amt)/255,0,1)*255; d[i+1]=clamp((d[i+1]+usG*amt)/255,0,1)*255; d[i+2]=clamp((d[i+2]+usB*amt)/255,0,1)*255; }
  return imageData;
}

/* ===== Export ===== */
els.buttons.exportNow.onclick=()=>doExport(false);
els.buttons.exportFull.onclick=()=>doExport(true);
function doExport(full){
  if(!S.imgBitmap){ setHUD('Open a photo first'); return; }
  setHUD(full?'Rendering full-res…':'Exporting…');
  const out=document.createElement('canvas'), g=out.getContext('2d'); out.width=S.origW; out.height=S.origH;
  g.save(); applyImageTransforms(g,0,0); drawWithPipeline(g,S.imgBitmap,S.params,full); g.restore();
  const rect=imageRectOnScreen();
  if(els.toggleText.checked && S.labels.length){
    g.save(); S.labels.forEach(l=>{ const ix=(l.x-rect.x)/S.zoom, iy=(l.y-rect.y)/S.zoom;
      g.globalAlpha=l.opacity; g.fillStyle=l.fill; g.font=`600 ${Math.round(l.size/S.zoom)}px Inter, system-ui`; g.textBaseline='alphabetic'; g.fillText(l.text,ix,iy); }); g.restore();
  }
  if(els.togglePaint.checked){
    const temp=document.createElement('canvas'); temp.width=els.paint.width; temp.height=els.paint.height; temp.getContext('2d').drawImage(els.paint,0,0);
    g.save(); g.translate((0-rect.x)/S.zoom,(0-rect.y)/S.zoom); g.scale(1/S.zoom,1/S.zoom); g.drawImage(temp,0,0); g.restore();
  }
  const mime=els.fmt.value, q=Number(els.quality.value);
  out.toBlob((blob)=>{ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`edited.${mime.split('/')[1]||'png'}`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); setHUD('Exported'); }, mime, q);
}
function loadPaintFromDataURL(dataURL){
  if(!dataURL){ clearPaintLayer(); return; }
  const img=new Image(); img.onload=()=>{ paintCtx.clearRect(0,0,els.paint.width,els.paint.height); paintCtx.drawImage(img,0,0,els.paint.width,els.paint.height); }; img.src=dataURL;
}

/* ===== Brush HUD (top-right) ===== */
(function(){
  const box=document.createElement('div');
  box.style.position='absolute'; box.style.right='12px'; box.style.top='86px'; box.style.background='#0c1420dd';
  box.style.border='1px solid var(--border)'; box.style.borderRadius='12px'; box.style.padding='10px';
  box.style.display='grid'; box.style.gridTemplateColumns='auto 160px'; box.style.gap='8px'; box.style.zIndex='10'; box.style.backdropFilter='blur(6px)';
  box.innerHTML=`
    <div class="label">Brush Size</div><input id="bSize" type="range" min="2" max="140" step="1" value="${S.brush.size}" class="range">
    <div class="label">Opacity</div><input id="bOp" type="range" min="0.05" max="1" step="0.01" value="${S.brush.opacity}" class="range">
    <div class="label">Hardness</div><input id="bHard" type="range" min="0" max="1" step="0.01" value="${S.brush.hardness}" class="range">
    <div class="label">Color</div><input id="bColor" type="color" value="${S.brush.color}" />
  `;
  document.body.appendChild(box);
  qs('#bSize').oninput=e=>S.brush.size=Number(e.target.value);
  qs('#bOp').oninput=e=>S.brush.opacity=Number(e.target.value);
  qs('#bHard').oninput=e=>S.brush.hardness=Number(e.target.value);
  qs('#bColor').oninput=e=>S.brush.color=e.target.value;
})();

/* ===== Demo image ===== */
function loadDemoImage(){
  const c=document.createElement('canvas'), g=c.getContext('2d');
  c.width=1600; c.height=900;
  const grd=g.createLinearGradient(0,0,1600,900);
  grd.addColorStop(0,'#304ffe'); grd.addColorStop(1,'#00e5ff');
  g.fillStyle=grd; g.fillRect(0,0,c.width,c.height);
  g.fillStyle='#ffffff'; g.font='900 220px Inter, system-ui'; g.globalAlpha=.12; g.fillText('pictr', 440, 520);
  const img=new Image();
  img.onload=async()=>{ await setBitmapFromImage(img); afterImageLoaded(); setHUD('Demo image loaded'); };
  img.src=c.toDataURL('image/png');
}

/* ===== Init ===== */
function setHUDReady(){ setHUD('Ready. Click Import, drop, or paste an image.'); }
function drawPaintLayer(){} // noop
buildUI(); resizeCanvases(); setHUDReady();

</script>
</body>
</html>
